---
title: 存在即合理
date: 2024-11-22 09:41:27
tags:
---

这是我的小牛马面经

# 理论，实践的根本

## npm 全部依赖符号 表示的意思

npm依赖符号用于定义在package.json文件中依赖包的版本范围，以下是常见符号及其含义：

- ‌无任何符号‌：必须匹配某个特定版本，如2.2.1。
- ‌>‌：必须大于某个版本，如>2.2.1。
- ‌>=‌：必须大于或等于某个版本，如>=2.2.1。
- ‌<‌：必须小于某个版本，如<2.2.1。
- ‌<=‌：必须小于或等于某个版本，如<=2.2.1。
- ‌\~‌：不改变大版本号和次要版本号，小版本号随意，如\\~2.2.1表示>=2.2.1 <2.3.0。
- ‌^‌：版本号最左边非0数字的右侧可以任意，如^2.2.1表示>=2.2.1 <3.0.0。
- ‌X‌：表示任意版本，如2.2.x表示>=2.2.0 <2.3.0。
- ‌\*\*\*\*\*‌：代替任意版本，如*表示>=0.0.0。
- ‌version(1) - version(2)‌：大于等于version(1)，小于等于version(2)。
- 此外，还有-S（--save）和-D（--dev）用于分别将包注册到dependencies和devDependencies中‌

devDependencies 和 dependencies 的区别：
结论：devDependencies 和 dependencies的区别核心体现在 npm包 中。只要开发的项目是发npm包提供给外部、其他业务项目使用的，需要非常注意依赖的安装地方，因为搞不好很容易在业务使用中会出现bug。而如果只是自己项目用，不需要发npm包的话，把依赖安装到 devDependencies 或者 dependencies 中，实质上是没有任何区别的。
为什么在开发 npm包 的时候 不严格区分 devDependencies 、 dependencies 进行装包可能会导致业务项目的使用中出现bug呢？笔者举一个例子来加深理解：

假设npm包开发者不小心把 vue3 的依赖写到了 dependencies 中（用于开发调试的），版本是 3.0.36。
业务项目自身用了 vue@3.0.0 的情况下，安装了这个 npm包 ，由于 npm包 中的 dependencies 有 vue@3.0.36 这个依赖，此时会在装 npm包 的同时安装36版本的vue。
由于 npm包中会用到vue，代码是这样引入的：import { onMount } from 'vue'，此时，npm包会在自己内部的 node_modules 中找到 vue@3.0.36 的包并使用，此时就会产生 2 个 vue3 实例，就很容易出现一些奇怪的bug。（业务项目的vue@3.0.0 和 npm包的vue@3.0.36）
这里还要注意一点就是 externals 。有同学可能会说，npm包打包的时候会 externals 掉第三方的库，比如上述中的 vue3 ，externals 只是保证 vue3 的代码不打包进 npm包 的代码中而已。

经过笔者上述的场景列举，大家应该都能get到，如果开发 npm包 中不严格区分 devDependencies 、 dependencies 的依赖安装，可能会导致用户处在使用 npm包 的时候出现问题。

<a href="https://juejin.cn/post/7135795969370619918">devDependencies 和 dependencies详解，生产打包与devDependencies还是dependencies无关，指的是 npm 包开发阶段所需依赖</a>

## git回退到某个提交记录commit查看当时的代码，不影响远程库

### 1. 查找提交记录：

首先，需要找到想要回退到的那个提交记录的哈希值。可以使用 `git log` 命令来查看提交历史

```bash
git log --oneline
```
这会列出所有的提交记录，每个记录只有一行，包括哈希值和提交信息。找到想要回退到的提交的哈希值。

### 2. 检出到特定提交

使用 `git checkout` 命令加上提交的哈希值，可以检出到那个特定的提交。
```bash
git checkout <commit-hash>
```

这里的 <commit-hash> 是找到的提交记录的哈希值。

### 3.查看代码：

现在，已经在那个特定的提交状态，可以查看当时的代码。

### 4.返回到最近的提交：

当查看完毕后，想要返回到最近的提交，可以使用以下命令：

```bash
git checkout master
```

或者如果不是在 `master` 分支，需要替换 `master` 为当前分支的名称。

### 5. 清理工作目录：

如果在检出到特定提交时做了任何更改，需要清理这些更改，以免影响返回到最近提交的状态。可以使用 `git reset` 命令来重置工作目录和索引，但不改变远程仓库的状态。

```bash
git reset --hard
```

这会将工作目录和索引重置到最后一次提交的状态。

## 原型，原型链

- 构造函数与原型：在JavaScript中，每个函数都有一个 `prototype` 属性，这个属性指向一个对象。当我们通过 new 关键字创建对象时，新对象的内部会包含一个指针 `__proto__`，指向`构造函数的 prototype` 对象。
- 原型链：对象之间通过prototype属性连接起来，形成原型链。当查找对象的属性或方法时，如果当前对象不存在，就会沿着原型链向上查找。
  
## 伪类、伪元素

- 伪类是选择器的一种，**它用于选择处于特定状态的元素**，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。它们表现得会像是你向你的文档的某个部分应用了一个类一样，帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护。

伪类就是开头为冒号的关键字。例如，`:hover` 就是一个伪类。

- 伪元素以类似方式表现。不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。

伪元素开头为双冒号 `::`。比如，`::before` 就是一个伪元素的示例。

## 盒模型、box-sizing

在 CSS 盒子模型的默认定义里，你对一个元素所设置的 width 与 height 只会应用到这个元素的内容区。如果这个元素有任何的 border 或 padding ，绘制到屏幕上时的盒子宽度和高度会加上设置的边框和内边距值。这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距。当我们实现响应式布局时，这个特点尤其烦人。

- content-box
  默认值，标准盒子模型。width 与 height 只包括内容的宽和高，不包括边框（border），内边距（padding），外边距（margin）。

- border-box
`width` 和 `height` 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks 模式 时 Internet Explorer 使用的盒模型。
尺寸计算公式：

**width = border + padding + 内容的宽度**
**height = border + padding + 内容的高度**